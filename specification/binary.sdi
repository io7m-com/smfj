[section [title SMFB - Binary Encoding] [id smfb]]

[subsection [title Header] [id smfb.header]]

[paragraph]
The [term [type type] SMFB] format is a binary encoding for the
[link [target smf_model.model] SMF model]. The format is separated
into a [link [target smfb.header.initial] header] and
[link [target smfb.data.initial] data] section.

[paragraph [id smfb.header.initial]]
All SMFB files begin with a fixed header. The start of the header uses a fixed
magic number and a major/minor version number pair indicating the major and
minor versions of the specification that defines the file structure.

[formal-item [title "Header (Start)"] [id smfb.header.start]]
[verbatim [include "jpra-header-start.txt"]]

[paragraph]
The magic number MUST always be [term [type constant] "0x89534d460d0a1a0a"];
implementations are required to immediately reject any files that do not
begin with this magic number. The derivation of this constant is taken almost
verbatim from the PNG [footnote-ref smfb.header.footnotes.png] file format
with the characters "PNG" changed to "SMF".

[footnote [id smfb.header.footnotes.png]]
[link-ext [target "https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header"] "https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header"]

[paragraph]
The rest of the header is given by the [term [type type] SMFBV1Header] type:

[formal-item [title "Header (Main)"] [id smfb.header.main.formal]]
[verbatim [include "jpra-header-v1-header.txt"]]

[paragraph [id smfb.header.schema_id]]
The [term [type type] SMFBV1SchemaID] type encodes the
[link [target smf_model.schema_id] schema ID]:

[formal-item [title "Header (schema ID)"] [id smfb.header.schema_id.formal]]
[verbatim [include "jpra-header-v1-schema.txt"]]

[paragraph [id smfb.header.coords]]
The [term [type type] SMFBV1CoordinateSystems] type encodes the
[link [target smf_model.coords] coordinate system]:

[formal-item [title "Header (Coordinate system)"] [id smfb.header.coords.formal]]
[verbatim [include "jpra-header-v1-coords.txt"]]

[paragraph]
The [term [type term] axis] and [term [type term] winding order] values are
related to integers in the binary encoding via the following functions:

[formal-item [title "Header (Coordinate system mapping)"] [id smfb.header.coords.map_formal]]
[verbatim [include "axis_map.hs"]]

[paragraph]
The header specifies the number of
[link [target smf_model.vertex] vertices] present in the file,
the number of [link [target smf_model.triangle] triangles] present in the file,
the size in bits of the individual triangle indices, and the number of
[link [target smf_model.attribute] attributes] present in the file.

[paragraph [id smfb.header.attributes]]
The header concludes by giving definitions for exactly [term [type variable] n]
attributes, where [term [type variable] n] is the attribute count specified
in the previous section of the header.

[formal-item [title "Header (Attributes)"] [id smfb.header.attributes.formal]]
[verbatim [include "jpra-header-v1-attribute.txt"]]

[paragraph [id smfb.header.alignment]]
The header is constructed with no implicit padding and no particular alignment.
However, the individual header structures are constructed such that their sizes
are always a multiple of [term [type constant] 8]. This ensures that the
[link [target smfb.data.initial] data] that immediately follows the header also
starts on an [term [type constant] 8] octet boundary.

[subsection [title Data] [id smfb.data]]

[paragraph [id smfb.data.initial]]
After the [link [target smfb.header.initial] header], the data for each
[link [target smf_model.attribute] attribute] is given in full in the
order in which the attributes were declared in the header. Specifically,
in a file containing [term [type variable] v] vertices and a list of
[term [type variable] n] attributes [term [type variable] a],
the file will contain [term [type variable] v] values of the type specified
in [term [type variable] "a !! 0"], followed by [term [type variable] v] values
of the type specified by [term [type variable] "a !! 1"], and so on up to
[term [type variable] "a !! n - 1"].

[paragraph [id smfb.data.alignment]]
The start of the data for each attribute
is aligned to the next [term [type constant] 8] octet boundary regardless
of type. The alignment is achieved by inserting padding octets at the end of
the previous attribute. For example, the following diagram shows how the data is
aligned for a file containing three vertices with two attributes
[term [type variable] "A"] and [term [type variable] "B"]. Attribute
[term [type variable] "A"] consists of three 16-bit floating-point components,
and attribute [term [type variable] "B"] consists for four 32-bit floating-point
components. As the file has three vertices, [term [type variable] "3 * 3 = 9"]
values are placed into the file first, consuming
[term [type variable] "3 * 3 * 2 = 18"] octets. Because the next octet,
[term [type variable] "18"], is not divisible by [term [type variable] "8"],
it's necessary to insert [term [type variable] "6"] octets of padding so that
the data for [term [type variable] "B"] will start on the next
[term [type variable] "8"] octet boundary.

[formal-item [title "Padding"] [id smfb.data.padding]]
[image [target "alignment.svg.png"] Padding for alignment]

[paragraph [id smfb.data.endianness]]
All values are stored in big-endian form.

[paragraph]
After all triangle and attribute data has been specified, the
[link [target smf_model.metadata] metadata] values are specified. A metadata
value begins with the following structure:

[formal-item [title "Metadata"] [id smfb.data.metadata]]
[verbatim
"[record SMFBV1Metadata
  ([field vendor [integer unsigned 32]]
   [field schema [integer unsigned 32]]
   [field size   [integer unsigned 64]])]"]

[paragraph]
The [term [type variable] vendor] and [term [type variable] schema] fields
are for use by applications to identify the types of metadata. The
[term [type variable] size] field records the size of the metadata in octets.

[paragraph]
This structure is followed by the opaque metadata octets with any additional
[link [target smfb.data.alignment] padding] to ensure that the next metadata
value occurs on an 8 octet boundary. The padding is not included in the recorded
size of the metadata.
